---
title: Outbox Transaccional con AsyncAPI, SpringCloud Stream y Spring Modulith
slug: /posts/TransactionalOutBoxWithAsyncAPIAndSpringModulith/
image: TransactionalOutBoxWithAsyncAPIAndSpringModulith-light-250.png
author: Ivan Garcia Sainz-Aja
date: 2025-01-03T09:00:00+02:00
excerpt: 'C贸mo implementar el patr贸n Outbox Transaccional con AsyncAPI, SpringCloud Stream, Spring Modulith y el Generador de C贸digo ZenWaveSDK para AsyncAPI.'
tags:
  - Transactional Outbox
  - AsyncAPI
  - ZenWave SDK
  - Code Generator
  - Spring Cloud Stream
  - Spring Modulith
---
import { Image } from "smooth-doc/components";

# Implementando un Outbox Transaccional con AsyncAPI, SpringModulith y ZenWaveSDK

## Introducci贸n

En sistemas distribuidos, donde los procesos involucran **m煤ltiples servicios sin una transacci贸n compartida**, garantizar la atomicidad y la consistencia representa un desaf铆o.

Las transacciones distribuidas con Two-Phase Commit (2PC) son complejas, introducen una sobrecarga de rendimiento significativa y pueden no ser factibles para ciertos servicios.

El **Patr贸n Outbox Transaccional** soluciona este problema utilizando una transacci贸n de base de datos para almacenar eventos en una tabla "outbox" dedicada, dentro de la misma transacci贸n que una actualizaci贸n en la base de datos. Luego, estos eventos se envian a los sistemas externos, como un servicio de correo electr贸nico o un broker de mensajes, garantizando consistencia eventual sin necesidad de transacciones distribuidas.

En este post, exploraremos c贸mo implementar un Patr贸n Outbox Transaccional para:

- Persistir datos en una base de datos transaccional soportada (por ejemplo, SQL o MongoDB).
- Enviar eventos a un broker de mensajes externo como Kafka o RabbitMQ usando Spring Cloud Stream.
- Aprovechar las caracter铆sticas transaccionales de eventos de Spring Modulith.
- Usar el generador de c贸digo ZenWaveSDK para AsyncAPI, eliminando la necesidad de escribir c贸digo boilerplate para el outbox transaccional y la publicaci贸n de eventos.

<Image dark="TransactionalOutBoxWithAsyncAPIAndSpringModulith-dark.png" light="TransactionalOutBoxWithAsyncAPIAndSpringModulith-light.png" alt="Transactional OutBox With AsyncAPI SpringCloud Stream And Spring Modulith" />


## Proyecto Playground de Ejemplo

Porque el software funcionando vale m谩s que mil palabras, usaremos un proyecto de prueba completamente funcional que puedes explorar y probar t煤 mismo.

Usaremos el siguiente proyecto como nuestro campo de pruebas: [EDA-TransactionalOutbox-Modulith-JPA](https://github.com/EDALearn/EDA-TransactionalOutbox-Modulith-JPA).

Este proyecto proporciona una API simple para gestionar detalles de clientes, incluyendo endpoints REST para operaciones CRUD. Estas operaciones publican notificaciones de eventos en un t贸pico de Kafka, usando Avro como formato de payload.

Componentes clave del proyecto incluyen:

- **Archivo de definici贸n OpenAPI**: [openapi.yml](https://github.com/EDALearn/EDA-TransactionalOutbox-Modulith-JPA/blob/main/src/main/resources/public/apis/openapi.yml)
- **Archivo de definici贸n AsyncAPI**: [asyncapi.yml](https://github.com/EDALearn/EDA-TransactionalOutbox-Modulith-JPA/blob/main/src/main/resources/public/apis/asyncapi.yml)
- **Esquemas Avro para eventos**: [Esquemas Avro](https://github.com/EDALearn/EDA-TransactionalOutbox-Modulith-JPA/tree/main/src/main/resources/public/apis/avro)


## Problema de Transacciones Distribuidas y el Patr贸n Outbox

<Image src="CustomerEvents.plantuml.png" />

Al gestionar la entidad `Customer`, surge un desaf铆o clave: garantizar la atomicidad al persistir los detalles del cliente en la base de datos y publicar un evento relacionado en un broker de mensajes externo. Dado que la base de datos y el broker no comparten una transacci贸n, esto puede llevar a potenciales inconsistencias.

### Escenarios Clave que Destacan el Problema:

1. **Evento Enviado Antes de que la Transacci贸n de la Base de Datos se Confirme**
Si el evento se publica antes de que la transacci贸n de la base de datos se confirme, una posible reversi贸n de la transacci贸n dejar铆a el sistema en un estado inconsistente, ya que el evento publicado no se puede deshacer.

2. **Evento Enviado Despu茅s de que la Transacci贸n de la Base de Datos se Confirme**
Si el evento se publica despu茅s de confirmar la transacci贸n en la base de datos, no hay garant铆a de que realmente se env铆e. Un fallo del servicio o una interrupci贸n en la red podr铆a impedir su publicaci贸n, resultando en una inconsistencia de datos.

```java
@Service
public class CustomerService {
    // ...

    @Transactional
    public Customer createCustomer(Customer input) {
        log.debug("Request to save Customer: {}", input);
        var customer = mapper.update(new Customer(), input);
        customer = customerRepository.save(customer); // Persist to DB

        var customerEvent = eventsMapper.asCustomerEvent(customer);
        eventsProducer.onCustomerEvent(customerEvent); // Emit Event to external Broker
        return customer;
    }
}
```

Con el patr贸n de outbox transaccional, en lugar de enviar el evento directamente al sistema externo, la llamada a `eventsProducer.onCustomerEvent(customerEvent)` almacena el evento en una tabla outbox dedicada, dentro de la misma transacci贸n que la actualizaci贸n de la base de datos. Luego, un proceso externo lee esta tabla y publica el evento en el broker de mensajes.

Sin embargo, implementar este proceso externo, gestionar la tabla outbox y garantizar que los eventos se publiquen una sola vez y en el orden correcto puede ser complejo y propenso a errores.

Afortunadamente, herramientas como el [Registro de Publicaci贸n de Eventos de Spring Modulith](https://docs.spring.io/spring-modulith/reference/events.html#publication-registry) y el [Generador de C贸digo ZenWaveSDK para AsyncAPI](https://www.zenwave360.io/zenwave-sdk/plugins/asyncapi-spring-cloud-streams3/) simplifican este proceso, permiti茅ndote enfocarte en la implementaci贸n de tu l贸gica de negocio.

## Generaci贸n de C贸digo ZenWaveSDK para AsyncAPI y Spring Cloud Streams

ZenWaveSDK genera, a partir de un archivo de definici贸n AsyncAPI, todo el c贸digo boilerplate necesario para el env铆o y recepci贸n de eventos con Spring Cloud Stream.

<iframe width="560" height="315" src="https://www.youtube.com/embed/d5xddNWYR5I?si=G9MQO9afhNIw6ym2" title="AsyncAPI: Full Code Generation for Java with ZenWave SDK" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

A partir de la definici贸n AsyncAPI, ZenWaveSDK genera:

- **DTOs/Modelos** para los payloads de tus eventos.
- **Objetos de Cabecera Tipados** para garantizar consistencia.
- **Interfaces Java con nombres expl铆citos**, basados en tus `operationIds`.
- Una implementaci贸n ligera con Spring Cloud Stream, que puede ser `@Autowire` directamente en tus servicios.

Luego, puedes configurar Spring Cloud Stream para enviar y recibir mensajes usando cualquiera de los [binders soportados](https://docs.spring.io/spring-cloud-stream/reference/index.html), como Kafka o RabbitMQ. Con ZenWaveSDK, no necesitas escribir c贸digo boilerplate, lo que te permite enfocarte completamente en tu l贸gica de negocio.

<details open>
  <summary>ZenWave SDK Maven Plugin Configuration</summary>

```xml
  <plugin>
    <groupId>io.github.zenwave360.zenwave-sdk</groupId>
    <artifactId>zenwave-sdk-maven-plugin</artifactId>
    <version>${zenwave.version}</version>
    <configuration>
      <inputSpec>${project.basedir}/src/main/resources/public/apis/asyncapi.yml</inputSpec>
      <addCompileSourceRoot>true</addCompileSourceRoot>
      <addTestCompileSourceRoot>true</addTestCompileSourceRoot>
    </configuration>
    <executions>
      <!-- DTOs -->
      <!-- we skip DTOs generation in this case b/c we are using Avro for that -->

      <!-- Generate PROVIDER -->
      <execution>
        <id>generate-asyncapi</id>
        <phase>generate-sources</phase>
        <goals>
          <goal>generate</goal>
        </goals>
        <configuration>
          <generatorName>spring-cloud-streams3</generatorName>
          <configOptions>
            <role>provider</role>
            <style>imperative</style>
            <transactionalOutbox>modulith</transactionalOutbox><!-- using Spring Modulith implementation -->
            <modelPackage>${asyncApiModelPackage}</modelPackage>
            <producerApiPackage>${asyncApiProducerApiPackage}</producerApiPackage>
            <consumerApiPackage>${asyncApiConsumerApiPackage}</consumerApiPackage>
          </configOptions>
        </configuration>
      </execution>
    </executions>
    <dependencies>
      // ...
    </dependencies>
  </plugin>
```
</details>

<details open>
  <summary>Avro Maven Plugin Configuration</summary>
```xml
<plugin>
  <groupId>org.apache.avro</groupId>
  <artifactId>avro-maven-plugin</artifactId>
  <version>1.11.1</version>
  <executions>
    <execution>
      <goals>
        <goal>schema</goal>
      </goals>
      <phase>generate-sources</phase>
    </execution>
  </executions>
  <configuration>
    <sourceDirectory>${project.basedir}/src/main/resources/public/apis/avro</sourceDirectory>
    <outputDirectory>${project.basedir}/target/generated-sources/avro</outputDirectory>
    <imports>
      <import>${project.basedir}/src/main/resources/public/apis/avro/PaymentMethodType.avsc</import>
      <import>${project.basedir}/src/main/resources/public/apis/avro/PaymentMethod.avsc</import>
      <import>${project.basedir}/src/main/resources/public/apis/avro/Address.avsc</import>
    </imports>
  </configuration>
</plugin>
```
</details>

Para ello, configuramos el `zenwave-sdk-maven-plugin` y, en este caso, tambi茅n el `avro-maven-plugin` en el archivo `pom.xml`. Esta configuraci贸n garantiza que el c贸digo necesario se genere en la carpeta `target/generated-sources` como parte del proceso de construcci贸n.

Dado que esta configuraci贸n se ejecuta autom谩ticamente durante la construcci贸n, cada vez que actualices tu archivo de definici贸n AsyncAPI, puedes estar seguro de que tu c贸digo se mantendr谩 sincronizado con la definici贸n de tu API.

<Image dark="ZenWaveSDK-Target-Generated-Sources-With-Arrow.png" light="ZenWaveSDK-Target-Generated-Sources-With-Arrow-light.png" />

Adem谩s, al configurar la opci贸n `transactionalOutbox` como `modulith`, ZenWaveSDK generar谩 autom谩ticamente el c贸digo necesario para utilizar el Registro de Publicaci贸n de Eventos de Spring Modulith, gestionando el outbox transaccional por ti.

<Image dark="ZenWaveSDK-TransactionalOutBox-Modulith-With-Arrows.png" light="ZenWaveSDK-TransactionalOutBox-Modulith-With-Arrows-light.png" />

## Registro de Publicaci贸n de Eventos de Spring Modulith

Al habilitar la Externalizaci贸n de Eventos y configurar los objetos `Message<?>` para su externalizaci贸n (ver abajo), estos eventos tambi茅n se almacenan de manera transaccional en el Registro de Publicaci贸n de Eventos de Spring Modulith.

```yaml
spring:
  modulith.events.externalization.enabled: true
  modulith.events.jdbc.schema-initialization.enabled: true
  modulith.events.republish-outstanding-events-on-restart: true
```

<Image dark="Modulith-Event-Publication-Registry.png" light="Modulith-Event-Publication-Registry-light.png" />

## Usando Spring Cloud Stream para Externalizar Eventos de Modulith

Ahora que Spring Modulith gestiona nuestros eventos de tipo `Message<?>`, necesitamos configurar uno de los muchos [externalizadores de eventos soportados](https://docs.spring.io/spring-modulith/reference/events.html#externalization).

Si public谩ramos POJOs en formato JSON, podr铆amos usar `spring-modulith-events-kafka` para externalizar eventos a un t贸pico de Kafka. Sin embargo, como queremos externalizar objetos `Message<?>` con payloads Avro, utilizaremos `io.zenwave360.sdk:spring-modulith-events-scs`, que admite la serializaci贸n y deserializaci贸n de `Message<?>`, con o sin payloads Avro.

Para m谩s detalles, consulta [ZenWave360 Spring Modulith Events para Spring Cloud Stream](https://github.com/ZenWave360/spring-modulith-events-spring-cloud-stream).

Para habilitar esta funcionalidad, a帽ade las siguientes dependencias a tu archivo `pom.xml`:

```xml
<dependency><!-- Spring Cloud Stream Externalization for Message<?> -->
    <groupId>io.zenwave360.sdk</groupId>
    <artifactId>spring-modulith-events-scs</artifactId>
    <version>${spring-modulith-events-scs.version}</version>
</dependency>
<dependency><!-- Needed for serializing Avro payloads to db storage as json -->
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-avro</artifactId>
</dependency>
```

Y `@EnableSpringCloudStreamEventExternalization` a nuestra configuraci贸n de Spring Boot:

```java
import io.zenwave360.modulith.events.scs.config.EnableSpringCloudStreamEventExternalization;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableSpringCloudStreamEventExternalization
class ExternalizationConfiguration {
}
```
Esto enruta autom谩ticamente nuestros objetos `Message<?>` al binding correcto de Spring Cloud Stream, gestion谩ndose en segundo plano sin necesidad de intervenci贸n manual.

```java
// this is some of what you get when adding @EnableSpringCloudStreamEventExternalization
@AutoConfiguration
@AutoConfigureAfter(EventExternalizationAutoConfiguration.class)
@ConditionalOnProperty(name = "spring.modulith.events.externalization.enabled", havingValue = "true",
        matchIfMissing = true)
public class MessageExternalizationConfiguration {

    @Bean
    EventExternalizationConfiguration eventExternalizationConfiguration() {
        return EventExternalizationConfiguration.externalizing()
            .select(event -> annotatedAsExternalized().test(event)
                    || event instanceof Message<?> && getTarget(event) != null)
            .route(Message.class, event -> RoutingTarget.forTarget(getTarget(event)).withoutKey())
            .build();
    }

    private String getTarget(Object event) {
        if (event instanceof Message<?> message) {
            return message.getHeaders()
                .get(SpringCloudStreamEventExternalizer.SPRING_CLOUD_STREAM_SENDTO_DESTINATION_HEADER, String.class);
        }
        return null;
    }
}
```

## Implementaci贸n Autom谩gica de Outbox Transaccional

Nuestro c贸digo original ahora implementa _autom谩gicamente_ el patr贸n Outbox Transaccional utilizando el Registro de Publicaci贸n de Eventos de Spring Modulith y Spring Cloud Stream, todo gracias al Generador de C贸digo AsyncAPI de ZenWaveSDK. 

```java
@Service
public class CustomerService {
    // ...

    @Transactional
    public Customer createCustomer(Customer input) {
        log.debug("Request to save Customer: {}", input);
        var customer = mapper.update(new Customer(), input);
        customer = customerRepository.save(customer); // Persist to DB

        var customerEvent = eventsMapper.asCustomerEvent(customer);
        eventsProducer.onCustomerEvent(customerEvent); // Emit Event to external Broker via Tx OutBox
        return customer;
    }
}
```

## Conclusi贸n

Implementar el patr贸n **Outbox Transaccional** con herramientas como **Spring Modulith** y **Spring Cloud Stream** permite garantizar la consistencia y la confiabilidad en el procesamiento de eventos.

Gracias a soluciones como **ZenWaveSDK**, la automatizaci贸n del proceso de generaci贸n de c贸digo y la integraci贸n con AsyncAPI **permiten enfocarse en la l贸gica de negocio** sin preocuparse por la implementaci贸n de c贸digo repetitivo.

