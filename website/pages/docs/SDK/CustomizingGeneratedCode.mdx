---
section: ZenWave SDK
title: Customizing Generated Code
slug: /docs/zenwave-sdk/customizing-code/
order: 9
---
import { Image, Quote, QuoteAuthor, Orange, RemoteCode } from 'smooth-doc/components'
import backendIntelliJPluginsImage from './images/SDK-Backend-IntelliJ-Plugins.png'
import sdkHexagonalDark from './images/SDK-ServiceImplementation-Hexagonal.dark.png'
import sdkHexagonalLight from './images/SDK-ServiceImplementation-Hexagonal.light.png'

# Customizing Generated Code
ZenWaveSDK adapts to your team's coding style, preferences and custom libraries.

ZenWave SDK arose from a personal need to have an analysis and design tool that could generate projects, initially Java and Spring-Boot, with sufficient flexibility to adapt to the needs of each project, team, and client.

By default, ZenWaveSDK generates a complete SpringBoot backend application following industry best practices, with a minimal dependency set: Spring-Data JPA and MongoDB, SpringMVC, SpringCloudStreams, MapStruct and optional Lombok integration.

You can customize the generated code in several ways:

**Basic Customization:**

- <Orange>Architecture layouts</Orange>: Choose between different architectural styles (layers, clean/hexagonal, simple packaging)
- <Orange>Package configuration</Orange>: Customize the structure of generated packages
- <Orange>Modular monoliths</Orange>: Configure multiple modules sharing common base classes

**Intermediate Customization:**

- <Orange>Custom templates</Orange>: Modify specific templates for small adjustments (annotations, custom starters, etc.)

**Advanced Customization:**
- <Orange>Classpath extension</Orange>: Add custom dependencies and plugins via JBang
- <Orange>Total customization</Orange>: Example of complete substitution replacing Java with Kotlin
- <Orange>Plugin creation</Orange>: Develop completely new plugins for specific cases

NOTE: The less customization you need, the less effort you'll spend creating and maintaining it.

## Configuring different Project Layouts

By default, ZenWave SDK generates a Spring Boot/Spring Cloud backend application using a flexible hexagonal/clean architecture approach. However, the toolkit offers several alternative layouts to match your preferred architectural style:

```zdl
config {
    title "My Backend Application"
    basePackage "com.example.my.backend"
    // Available layout options:
    //      - DefaultProjectLayout
    //      - CleanHexagonalProjectLayout
    //      - LayeredProjectLayout
    //      - SimpleDomainProjectLayout
    //      - HexagonalProjectLayout
    //      - CleanArchitectureProjectLayout
    layout CleanHexagonalProjectLayout
}
```

You can customize any package path in your chosen layout through properties in the config section or as parameters in the CLI plugin:

```zdl
config {
    //...
    layout CleanHexagonalProjectLayout

    layout.entitiesPackage "{{basePackage}}.core.model"
    layout.openApiApiPackage "{{basePackage}}.web"
    layout.openApiModelPackage "{{basePackage}}.web.dtos"
}
```

For a complete customization, you can create your own implementation of the [ProjectLayout](https://github.com/ZenWave360/zenwave-sdk/blob/main/zenwave-sdk-cli/src/main/java/io/zenwave360/sdk/zdl/layouts/ProjectLayout.java#L13) class.

> Tip: You can organize your application into multiple modules, each using a different layout.

### CleanHexagonalProjectLayout

This is the default project layout, which the source code templates are designed around. It implements a pragmatic hexagonal/clean architecture with:
- A central `core` package containing domain entities and aggregates
  - `inbound` (primary ports) and `outbound` (secondary ports) interfaces
  - and the internal `implementation` of `inbound` interfaces, which uses the `outbound` interfaces to interact with external services.

&nbsp;
<RemoteCode summary="CleanHexagonalProjectLayout" visibleRange="3,33" language="java" collapsed={false} showLegend={true}
            url="https://github.com/ZenWave360/zenwave-sdk/blob/main/zenwave-sdk-cli/src/main/java/io/zenwave360/sdk/zdl/layouts/CleanHexagonalProjectLayout.java" />
&nbsp;
<Image alt="ZenWave SDK Modeling Languages" src={sdkHexagonalDark} />

#### Notes about Generated Clean/Hexagonal Architecture

To balance pragmatism with architectural purity, this implementation makes two practical compromises:

1. Domain entities directly use JPA or SpringData MongoDB annotations
2. Spring Data Repository interfaces serve as outbound adapters/secondary ports, while their implementations remain outside the core domain

These design choices significantly reduce the complexity of your codebase by minimizing the number of mappers and DTOs needed, while still maintaining the key benefits of hexagonal/clean architecture - clear separation between core domain and external systems.

For testing, ZenWave SDK provides in-memory implementations of Spring Data Repository interfaces, eliminating the need for a database or mocking frameworks. This demonstrates that your core business logic remains decoupled from specific persistence technologies.

If you believe your project genuinely requires the ability to swap persistence implementations (a rare need in most applications), and you're willing to accept the additional complexity of extra mapping layers, you can create custom templates as described in the [Full Source Code Customization](#full-source-code-customization) section.

### LayeredProjectLayout

This is the classical layered architecture with `domain`, `repository`, `events`, `commands`, `service` and `web` layers.

<RemoteCode summary="LayeredProjectLayout" visibleRange="3,33" language="java" collapsed={false} showLegend={true}
            url="https://github.com/ZenWave360/zenwave-sdk/blob/main/zenwave-sdk-cli/src/main/java/io/zenwave360/sdk/zdl/layouts/LayeredProjectLayout.java" />

### SimpleDomainProjectLayout

This is a very simple and flat structure, with no particular layering. It's useful for small services or modules with just one entity or aggregate.

<RemoteCode summary="SimpleDomainProjectLayout" visibleRange="3,33" language="java" collapsed={false} showLegend={true}
            url="https://github.com/ZenWave360/zenwave-sdk/blob/main/zenwave-sdk-cli/src/main/java/io/zenwave360/sdk/zdl/layouts/SimpleDomainProjectLayout.java" />

### HexagonalProjectLayout

This layout follows a stricter naming convention for hexagonal architecture, with domain, ports, application core, and adapters.

<RemoteCode summary="HexagonalProjectLayout" visibleRange="3,35" language="java" collapsed={false} showLegend={true}
            url="https://github.com/ZenWave360/zenwave-sdk/blob/main/zenwave-sdk-cli/src/main/java/io/zenwave360/sdk/zdl/layouts/HexagonalProjectLayout.java" />


## Modular Monoliths

Initially, ZenWave SDK was designed to generate microservices, although nothing prevents using it to generate modules of a monolith.

The main peculiarity when building modular monoliths is sharing base classes between different modules to avoid code duplication.

For monolithic projects, it's necessary to configure the module's base package name, which will be the root package of all packages generated by ZenWave SDK (equivalent to `basePackage` in microservices).

```zdl
// Module-specific configuration
config {
    title "Customer Module"
    layout CleanHexagonalProjectLayout
    layout.moduleBasePackage "io.zenwave360.example.modules.customers"
}
```

And also configure the base packages to share classes between modules, as they will probably be at a higher level than the modules themselves.

```zdl
// Common configuration for all modules
config {
    title "Modular Monolith"
    basePackage "io.zenwave360.example"

    // Packages shared between modules
    layout.commonPackage "{{basePackage}}.common"
    layout.infrastructureRepositoryCommonPackage "{{commonPackage}}"
    layout.adaptersWebMappersCommonPackage "{{commonPackage}}.mappers"
}
```

See:
- [Clinical Tool - Modular Monolith](https://github.com/ZenWave360/zenwave-playground/tree/main/examples/modulith-clinical-tool-jpa)
- [Klinical Tool - Modular Monolith](https://github.com/ZenWave360/zenwave-playground/tree/main/examples/modulith-klinical-tool-jpa)

For two examples of modular monoliths generated with ZenWave SDK, in Java and Kotlin, respectively.

## Intermediate Customization

### Custom Templates

For specific modifications without creating a complete plugin, you can override individual templates:

**Process:**
1. Locate the original template in the ZenWave SDK repository
2. Copy the template to `.zenwave/templates/[original-path]` in your project root folder
3. Modify the content according to your needs

**Example:** Customize Spring Data repositories with file like this:

<RemoteCode summary=".zenwave/templates/io/zenwave360/sdk/plugins/BackendApplicationDefaultGenerator/src/main/java/core/outbound/jpa/imperative/EntityRepository.java.hbs" language="hbs" collapsed={true} showLegend={false}
            content={`
// .zenwave/templates/io/zenwave360/sdk/plugins/BackendApplicationDefaultGenerator/src/main/java/core/outbound/jpa/imperative/EntityRepository.java.hbs
package {{layout.outboundRepositoryPackage}};
{{~assign 'aggregate' (findEntityAggregate entity.name)}}

import {{layout.entitiesPackage}}.*;
import java.math.*;
import java.time.*;
import java.util.*;

import org.springframework.data.jpa.repository.*;
import org.springframework.stereotype.Repository;

/**
 * Spring Data JPA repository for the {{entity.className}} entity.
 */
@Repository
@MyCustomRepositoryAnnotation
public interface {{entity.className}}Repository extends MyCustomBaseRepository<{{entity.className}}, {{idJavaType}}> {

{{~#if aggregate}}
    default Optional<{{aggregate}}> find{{aggregate}}ById({{idJavaType}} id) {
    return findById(id).map({{aggregate}}::new);
    }
{{~/if}}

{{~#if (naturalIdFields entity)}}{{{naturalIdsRepoMethodSignature entity}}};{{/if}}
}
            `} />

Notice `@MyCustomRepositoryAnnotation` and `extends MyCustomBaseRepository` added to the template.

**Limitations:** This approach allows modifying templates but not adding new helpers or changing generation logic.

## Advanced Customization

### Importing Custom Maven Artifacts

Custom Maven artifacts can be used to **extend, replace, or override** the default behavior of ZenWave. These artifacts may contain:

- **Handlebars templates** that override existing templates
- **Alternative implementations of existing Java classes**
- **New plugins** not included in the default distribution
- **Additional customizations** such as helpers, generators, or conventions

When present, these imported artifacts are loaded **before parent classpath** so they take precedence over built-in components.

You can import custom Maven artifacts by adding them to the jbang command line using the `--deps` option, for example:

```shell
jbang --deps=org.example:custom-artifact:1.0.0 \
  zw -p BackendApplicationDefaultPlugin zdlFile=zenwave-model.zdl
```

Alternatively, if you are using the ZenWave Editor IntelliJ Plugin
, you can declare the dependency directly in your .zw file:

```zdl
@import("org.example:custom-artifact:RELEASE")
config {
    //...
}
```

When running plugins from `.zw` files, ZenWave Editor automatically resolves these imports and adds them to the underlying jbang execution.

### Classpath Extension with JBang

You can also extend the classpath by creating a custom `jbang-catalog.json` file in the project root, which would override ZenWave SDK's classpath when invoked from that directory:

```json
{
  "catalogs": {},
  "aliases": {
    "zw": {
      "script-ref": "io.github.zenwave360.zenwave-sdk:zenwave-sdk-cli:RELEASE",
      "dependencies": [
        "org.slf4j:slf4j-simple:1.7.36",
        "<your-custom-dependency>",
        // ... standard ZenWave dependencies
      ],
      "main": "io.zenwave360.sdk.Main"
    }
  }
}
```

**Important note:** Dependencies added at the beginning will override ZenWave SDK classes.

### Total customization: Example of complete substitution replacing Java with Kotlin

ZenWave SDK allows total customization. In fact, it includes a complete customization that replaces Java with Kotlin.

You can check the [Kotlin customization source code](https://github.com/ZenWave360/zenwave-sdk/tree/main/plugins/customizations/kotlin-backend-application) to see how it's implemented.

In practical terms, to use the Kotlin customization, simply configure the `templates` option with the corresponding class in the following plugins:

```zdl
@import("io.zenwave360.sdk.plugins.customizations:kotlin-backend-application:RELEASE")
config {
    zdlFile "zenwave-model.zdl"

    plugins {
        BackendApplicationDefaultPlugin {
            templates "new io.zenwave360.sdk.plugins.kotlin.BackendApplicationKotlinTemplates()"
        }

        OpenAPIControllersPlugin {
            openapiFile "src/main/resources/public/apis/openapi.yml"
            templates "new io.zenwave360.sdk.plugins.kotlin.OpenAPIControllersKotlinTemplates()"
        }

        SpringWebTestClientPlugin {
            openapiFile "src/main/resources/public/apis/openapi.yml"
            templates "new io.zenwave360.sdk.plugins.kotlin.SpringWebTestClientKotlinTemplates()"
        }
    }
}
```

You can find several complete examples of Kotlin projects generated by this customized templates in https://github.com/ZenWave360/zenwave-playground/

### Creating Custom Plugins

For specific needs, you can create completely new plugins that generate any type of artifact: code, APIs, documentation, tests...

**Available tools:**
- ZDL Parser
- OpenAPI/AsyncAPI Parser with reference resolution
- Java code formatters (Google, Palantir, Spring) and Kotlin (ktfmt)
- Handlebars template engine

You can base your work on any existing plugin and/or use the `ZdlToJsonPlugin` Plugin to inspect the ZDL model structure and understand the transformations needed to achieve your goal.

```bash
jbang zw -p ZdlToJsonPlugin zdlFile=zenwave-model.zdl
```

The best way to start is to fork an existing plugin and modify it to suit your needs. You can find all available plugins in the [ZenWave SDK repository](https://github.com/ZenWave360/zenwave-sdk/tree/main/plugins).
